#!/bin/zsh -f

typeset -r help_message='USAGE
  o gold [--help|-h]
    Display this help message.

  o gold (--version|-v)
    Display the version.

  o gold <config-file> [<sub-command>]
    <config-file>
      Config file path, written in Zsh, which must define the following vars:
        * test_cases
            Associative array. Keys are test case names and values are commands.
            The commands can have the placeholder <N>, which is substituted by
            the name of the test case before the command is executed.
        * resources
            Holds the path to a dir to provide data for the command. At a
            minimum, it is expected that for each test case there is one golden
            file in this directory with the name `<test_case_name>_golden.txt`.
    <sub-command>
      See the section SUB-COMMANDS. Default: `run`.

SUB-COMMANDS
  * ls
      List all test cases.
  * run [<test-case-name>]
      Run all test cases or a single test case by name.
  * patch [<text-case-name>]
      Patch (with `run`s output) all test cases or a single test case by name.
  * exec <test-case-name>
      Execute the command corresponding to a test case by name.

EXAMPLES
  * List all test cases: `zgold test/all_pass/config.zsh ls`
  * Run all test cases: `zgold test/all_pass/config.zsh run`'

# Form: gold [--help|-h]

if [[ "${1}" = '--help' ]] || [[ "${1}" = '-h' ]] || [[ "${#@}" -eq 0 ]]; then
  echo "${help_message}"
  return 0
fi

# Form: gold (--version|-v)

if [[ "${1}" = '--version' ]] || [[ "${1}" = '-v' ]]; then
  echo '0.3.1-dev'
  return 0
fi

# Form: gold <config-file> <sub-command>

. "${1}"

## @param $1 Command.
## @param $2 Test case name.
function _build_command {
  echo "${${1}//<N>/${2}}"
}

## @param $1 Test case name.
## @param $2 Resources directory path.
## @param $3 Command used to get the result to compare with the golden file.
## @param $4 (optional) Patch or not to patch. By default, do not patch.
## @stdout Diff or patch output.
function _run_test {
  echo "${1}"

  # setup - data
  local golden_file_path="${2}/${1}_golden.txt"
  local command_output="$(eval $(_build_command "${3}" "${1}"))"

  # execute
  local diff=$(diff -u "${golden_file_path}" <(echo "${command_output}"))

  if [[ "${4}" = 'patch' ]]; then
    # The command `patch` is not used since I ran into an error `patch:1:
    # division by zero`.
    echo "${command_output}" > "${golden_file_path}"
    echo "Patch complete for: ${golden_file_path}"
  elif [[ -n "${diff}" ]]; then
    # verify
    command -v delta >/dev/null \
      && echo "${diff}" | delta --pager 'less -rFX' \
      || echo "${diff}"
  fi
}

# SUB COMMANDS

## List all test cases.
function ls {
  for test_case_name in ${(k)test_cases}; do
    echo ${test_case_name}
  done
}

## Run all test cases or a single test case by name.
## @param $1 Test case name.
function run {
  if [[ -z ${1} ]]; then
    for test_case_name test_case_command in ${(kv)test_cases}; do
      _run_test "${test_case_name}" "${resources}" "${test_case_command}"
    done
    exit 0
  fi
  _run_test ${1} "${resources}" "${test_cases[${1}]}"
}

## Default sub-command: `run`.
if [[ ${#@} -eq 1 ]]; then
  run
  exit 0
fi

## Patch (with `run`s output) all test cases or a single test case by name.
## @param $1 Test case name.
function patch {
  if [[ -z ${1} ]]; then
    for test_case_name test_case_cmd in ${(kv)test_cases}; do
      _run_test "${test_case_name}" "${resources}" "${test_case_cmd}" 'patch'
    done
    exit 0
  fi
  _run_test "${1}" "${resources}" "${test_cases[${1}]}" 'patch'
}

## Run the command for a single test case by name.
## @param $1 Test case name.
function exec {
  eval $(_build_command "${test_cases[${1}]}" "${1}")
}

eval "${@[@]:2}"
