#!/bin/zsh -f

typeset -r help_message='USAGE
  o zgold [--help|-h]
    Display this help message.

  o zgold (--version|-v)
    Display the version.

  o zgold <config-file> [<sub-command>]
    <config-file>
      Config file path, written in Zsh. If this arg is a dir path instead of a
      file path, then the file is assumed to be `config.zsh` within the dir. The
      config file must define the following vars:
        * test_cases
            Associative array. Keys are test case names and values are commands.
            The commands can have the placeholder <N>, which is substituted by
            the name of the test case before the command is executed.
        * resources
            Holds the path to a dir to provide data for the command. At a
            minimum, it is expected that for each test case there is one golden
            file in this directory with the name `<test_case_name>_golden.txt`.
      Optionally, the config file may also define these vars:
        * pre_diff_hooks
            Associative array. Keys are test case names and values are commands.
            The output of the test case command is piped to the pre diff hook
            command. This happens before the diff against the golden file. This
            is useful to remove parts of the output of the test case command
            which are expected to change among runs, such as timestamps.
    <sub-command>
      See the section SUB-COMMANDS. Default: `run`.

  o zgold -b <directory...>
    Batch run. Execute the sub-command `run` for every directory.
    <directory>
      A dir which has a `config.zsh` file as per expected by the command form
      `zgold <config-file [<sub-command>]`. Useful for CI.

SUB-COMMANDS
  * ls
      List all test cases.
  * run [<test-case-name>]
      Run all test cases or a single test case by name.
  * patch [<test-case-name>]
      Patch (with `run`s output) all test cases or a single test case by name.
  * exec <test-case-name>
      Execute the command corresponding to a test case by name.

EXIT CODES
  The exit code is the total of failed test cases.

EXAMPLES
  * List all test cases: `zgold test/all_pass/config.zsh ls`
  * Run all test cases: `zgold test/all_pass/config.zsh run`
  * Run all test cases: `zgold test/all_pass`'

# Command line argument parsing code from:
# <https://github.com/hernancerm/args.zsh>
function parse_args {
  local -A args=()
  local -a args_pos=()
  eval "local -a bool_opts=(${1})"
  eval "local -A defaults=(${2})"
  local -a user_args=(${@[@]:3})
  local skip_parse_of_current_arg='false'
  for (( i=1 ; i<=${#user_args} ; i++ )); do
    if [[ "${skip_parse_of_current_arg}" = 'true' ]]; then
      skip_parse_of_current_arg='false'
      continue
    fi
    # If arg begins with a dash (-) then it's an option.
    if [[ "${${user_args[${i}]}[1]}" = '-' ]]; then
      # Check if the option is bool(ean).
      if [[ ${bool_opts[(i)${user_args[i]}]} -le ${#bool_opts} ]]; then
        args+=(["${user_args[${i}]}"]='true')
      else
        args+=(["${user_args[${i}]}"]="${user_args[$((i+1))]}")
        skip_parse_of_current_arg='true'
      fi
      continue
    fi
    # Otherwise, it's a positional arg.
    args_pos+=("${user_args[$((i))]}")
  done
  # Serialize positional args as an iarray.
  args[positional]="$(typeset -p args_pos)"
  # Assign default values to unset options.
  for flag_name flag_value in ${(kv)defaults}; do
    if [[ -z "${args[${flag_name}]}" ]]; then
      args+=([${flag_name}]=${flag_value})
    fi
  done
  # Print aarray.
  typeset -p args
}

# Parse command line arguments.
eval "$(parse_args \
  '--help -h --version -v -b' '' ${@})"
eval "${args[positional]}"

## @param $1 Command.
## @param $2 Test case name.
function _build_command {
  echo "${${1}//<N>/${2}}"
}

## @param $1 Test case name.
## @param $2 Resources directory path.
## @param $3 Command used to get the result to compare with the golden file.
## @param $4 (optional) Patch or not to patch. By default, do not patch.
## @stdout Diff or patch output.
function _run_test {
  if [[ -d "${args_pos[1]}" ]]; then
    echo "$(basename -a ${2}) -- ${1}"
  else
    echo "${1}"
  fi

  # setup - data
  local golden_file_path="${2}/${1}_golden.txt"
  local cmd_output="$(eval $(_build_command "${3}" "${1}"))"
  if ! [[ -f "${golden_file_path}" ]]; then
    touch "${golden_file_path}"
  fi
  if [[ -n ${pre_diff_hooks} ]] && [[ -n "${pre_diff_hooks[${1}]}" ]]; then
    cmd_output="$(eval "echo \"${cmd_output}\" | ${pre_diff_hooks[${1}]}")"
  fi

  # execute
  local diff=$(diff -u "${golden_file_path}" <(echo "${cmd_output}"))

  if [[ "${4}" = 'patch' ]]; then
    echo "${cmd_output}" > "${golden_file_path}"
    echo "Patch complete for: ${golden_file_path}"
  elif [[ -n "${diff}" ]]; then
    # verify
    command -v delta >/dev/null \
      && echo "${diff}" | delta --pager 'less -rFX' \
      || echo "${diff}"
    return 1
  fi
  return 0
}

## @stdout Static header.
function _print_header {
  local message='Launching ZGold'
  if [[ -n "${STDOUT_TO_TERM}" ]]; then
    echo "\e[33m${message}\e[0m"
  else 
    echo "${message}"
  fi
  echo "ZGold: $(zgold -v)"
  echo "ZSH:   $(zsh --version)"
}

## @param $1 Amount of total test cases.
## @param $2 Amount of failed test cases.
## @param $3 Time in seconds execution took.
## @stdout Footer.
function _print_footer {
  local message='Results'
  echo "${1} tests run in ${3}s"
  echo
  if [[ -n "${STDOUT_TO_TERM}" ]]; then
    echo "\e[33m\e[4m${message}\e[0m"
  else
    echo "${message}"
  fi
  echo "Passed $(( ${1} - ${2} ))"
  echo "Failed ${2}"
}

# Detect if stdout refers to a terminal.
if [[ -t 1 ]]; then
  STDOUT_TO_TERM='true'
fi

# Form: zgold [--help|-h]

if [[ "${args[--help]}" = 'true' ]] \
    || [[ "${args[-h]}" = 'true' ]] \
    || [[ "${#@}" -eq 0 ]]; then
  echo "${help_message}"
  exit 0
fi

# Form: zgold (--version|-v)

if [[ "${args[--version]}" = 'true' ]] \
    || [[ "${args[-v]}" = 'true' ]]; then
  echo '0.4.1-dev'
  exit 0
fi

# Form: zgold -b <directory...>

if [[ "${args[-b]}" = 'true' ]]; then
  typeset -i exit_code=0
  typeset -i total_test_cases=0
  _print_header
  echo
  local start_time=$(date +%s)
  for dir in ${args_pos}; do
    . "${dir}/config.zsh"
    for test_case_name test_case_command in ${(kv)test_cases}; do
      _run_test "${test_case_name}" "${resources}" "${test_case_command}"
      exit_code+=$?
      total_test_cases+=1
    done
  done
  local end_time=$(date +%s)
  echo
  _print_footer \
    ${total_test_cases} ${exit_code} $(( ${end_time} - ${start_time} ))
  # Total of failed test cases.
  exit ${exit_code}
fi

# SUB COMMANDS

# Form: zgold <config-file> [<sub-command>]

if [[ -f "${args_pos[1]}" ]] . "${args_pos[1]}"
if [[ -d "${args_pos[1]}" ]] . "${args_pos[1]}/config.zsh"

## List all test cases.
function ls {
  for test_case_name in ${(k)test_cases}; do
    echo "${test_case_name}"
  done
}

## Run all test cases or a single test case by name.
## @param $1 Test case name.
function run {
  _print_header
  echo
  # Run all tests from a config file.
  if [[ -z ${1} ]]; then
    typeset -i exit_code=0
    local start_time=$(date +%s)
    for test_case_name test_case_command in ${(kv)test_cases}; do
      _run_test "${test_case_name}" "${resources}" "${test_case_command}"
      exit_code+=$?
    done
    local end_time=$(date +%s)
    echo
    _print_footer ${#test_cases} ${exit_code} $(( ${end_time} - ${start_time} ))
    # Total of failed test cases.
    exit ${exit_code}
  fi
  # Run a single test from a config file.
  local start_time=$(date +%s)
  _run_test "${1}" "${resources}" "${test_cases[${1}]}"
  local end_time=$(date +%s)
  echo
  _print_footer 1 $? $(( ${end_time} - ${start_time} ))
  # Total of failed test cases.
  exit $?
}

## Patch (with `run`s output) all test cases or a single test case by name.
## @param $1 Test case name.
function patch {
  if [[ -z ${1} ]]; then
    for test_case_name test_case_cmd in ${(kv)test_cases}; do
      _run_test "${test_case_name}" "${resources}" "${test_case_cmd}" 'patch'
    done
    exit 0
  fi
  _run_test "${1}" "${resources}" "${test_cases[${1}]}" 'patch'
}

## Run the command for a single test case by name.
## @param $1 Test case name.
function exec {
  eval $(_build_command "${test_cases[${1}]}" "${1}")
}

cmd="${args_pos[2,-1]}"
# Default sub-command: `run`.
if [[ ${#args_pos} -eq 1 ]] cmd='run'

# Execute sub-comand.
eval "${cmd}"
